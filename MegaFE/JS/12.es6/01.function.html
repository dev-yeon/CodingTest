<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    /*
    화살표 함수
    es6 에 새로 추가된 함수 표현식 

    */

    // 기본적인 함수 표현식 
    test01() // 호이스팅이 가능
    function test01() {
      console.log('test');
    }
    test01()

    // 변수 선언식 
    //test02('test02') // 호이스팅 불가능 
    let test02 = function () {
      console.log('test02')
    }
    test02() // 변수명으로 호출 

    // 새로 추가된 화살표 함수 
    //test03() // 함수가 없다고 뜸.
    test03 = () => {
      console.log('test03');

    }
    test03()

    let test04 = () => console.log('test04');
    test04()
    // 출력할 코드가 하나라면 코드 블럭을 생략 할 수 있다. 

    let test05 = (a) => console.log(a * a);
    test05(5);

    let test06 = a => console.log(a * a);
    test06(6)
    // 매개 변수가 하나라면, ()를 생략 되어도 된다. 
    // 화살표 함수로는 생성자 함수를 만들수 없다. 
    // 이유는 this의 바인딩과 prototype의 특성과 관련이 있기 때문

    function person(name) {
      this.name = name;
    }

    const kim = new Person('kim');
    console.log(kim.name)

    let Person01 = (name) => {
      this.name = name
    }

    const park = new Person01('park');
    console.log(park.name) //TypeError :  person01 is not a constructor 

    // 화살표 함수에서의 this 는 전역 객체를 참조하거나 undefined

    /*
    일반 함수에서의 this는 함수가 호출 할때의 컨텍스트에 따라서 동적으로 결정된다. 
    즉 호출하는 방식에 따라서 this의 선택자가 달라지게 된다. 

    화살표 함수에서의 this는 자기 자신만의 this를 가지지 않고, 정해진 컨텍스트의 this만 참조하도록 설계되어 있다. 
    화살표 함수는 호출된 위치의 this를 그대로 사용하기 때문에.  인스턴스의 this를 참조하지 못하게 된다. 
    */

  </script>
</head>

<body>

</body>

</html>